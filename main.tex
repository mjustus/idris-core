\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{mathtools}

\usepackage[utf8]{inputenc}
\usepackage{fontenc}

\usepackage{stmaryrd}

\usepackage{mathpartir}
\renewcommand{\TirNameStyle}[1]{{\scriptsize {\textsc {[#1]}}}}

\usepackage{url}
\usepackage{hyperref}

\usepackage{xcolor}

\definecolor{term}{RGB}{153,0,0}
\definecolor{type}{RGB}{0,0,224}
\definecolor{definition}{RGB}{0,102,0}
\definecolor{neutral}{RGB}{102,0,102}
\definecolor{meta}{RGB}{224,153,0}

\usepackage{todonotes}

%\usepackage[top=0.75in, bottom=1in, left=1in, right=1in]{geometry}

\title{Yaffle}

\newcommand{\used}[2]{\textsf{lin}(#1,#2)}
\newcommand{\usageCount}[2]{\textsf{count}(#1,#2)}

\newcommand{\ceil}[1]{\left\lceil #1\right\rceil}
%\newcommand{\restrictOne}[1]{\left[ #1\right]_{\mathbb I}}
%\newcommand{\presence}[1]{\left\vert#1\right\vert_{\zero\one}}
\newcommand{\presence}[1]{\left\vert#1\right\vert}

\newcommand{\delete}[1]{\left\lvert #1\right\rvert}
\newcommand{\deleteQ}[2]{\textsf{erase}^{#2}\left(#1\right)}

\newcommand{\USES}{\triangleright}
\newcommand{\ENT}{\vdash}
\newcommand{\ENTq}[1]{\vdash^{#1}}
\newcommand{\OF}{:}
\newcommand{\TO}{\Rightarrow}
\newcommand{\INq}[1]{}
\newcommand{\OFq}[1]{\OF^{#1}}
\newcommand{\TOq}[1]{\TO^{#1}}
\newcommand{\EQ}{\ensuremath{\mathbin{\equiv}}}

\newcommand{\EMPTY}{.}

\newcommand{\checkJ}[5]{#1; #2 \ENT {#3} \OFq {#4} #5}

\newcommand{\convJ}[5]{\Sigma; #1 \ENT {#2} = {#3} \OFq {#4} #5}

\newcommand{\linCheckJ}[4]{\Sigma; #1 \ENT {#2} \USES^{#3} {#4}}

\newcommand{\eqJ}[6]{#1; #2 \ENT {#3} = {#4} \OFq {#5} #6}
\newcommand{\checkEqJ}[6]{#1; #2 \ENT {#3} = {#4} \OFq {#5} #6}

\newcommand{\type}[1]{{\textcolor{type}{\textsf{#1}}}}
\newcommand{\term}[1]{{\textcolor{term}{\textsf{#1}}}}
\newcommand{\definition}[1]{{\textcolor{definition}{\textsf{#1}}}}
\newcommand{\unv}[1]{{\textcolor{type}{\textsc{#1}}}}

\newcommand{\zero}{{\textcolor{type}{0}}}
\newcommand{\one}{{\textcolor{type}{1}}}
\newcommand{\any}{{\textcolor{type}{\omega}}}

\newcommand{\restrictQ}[2]{#1 \setminus #2}
\newcommand{\multQ}[2]{{#1} \cdot {#2}}
\newcommand{\restrictAny}[1]{\restrictQ {#1} \any}

\newcommand{\name}[1]{{\textcolor{neutral}{#1}}}
\newcommand{\metaVariable}[1]{{\textcolor{meta}{#1}}}

\newcommand{\Type}{\unv{Type}}
\newcommand{\One}{\type{1}}
\newcommand{\To}{\mathbin{\textcolor{type}{\shortrightarrow}}}
% \newcommand{\App}[3]{#2^{#1}\, #3}
\newcommand{\App}[3]{\term{App}^{#1}\left(#2,#3\right)}
\newcommand{\Sub}[3]{#1 [#2/{\name #3}]}
\newcommand{\AppTele}[3]{\term{App}\left(#1\overline{,^{#2} {#3}}\right)}
\newcommand{\MetaApp}[3]{\term{MetaApp}\left(\metaVariable {#1} \overline{,^{#2} {#3}}\right)}
\newcommand{\TyCon}[1]{\type{TyCon}\left({\definition {#1}}\right)}
\newcommand{\DataCon}[1]{\term{DataCon}\left({\definition {#1}}\right)}
\newcommand{\lam}[3]{\textcolor{term}{\lambda} {(\name {#1} \OFq {#2} {#3})}.\,}
\newcommand{\Let}[5]{\term{let}\, {\name #1} \OFq {#2} {#3} := {#4} \mathbin{\term{in}} {#5}}

% \newcommand{\Inf}[1]{\overline{#1}}
% \newcommand{\Annot}[2]{\left(#1 \OF #2\right)}

\newcommand{\fv}[1]{\text{fv}(#1)}

\newcommand{\Def}[2]{\definition{#1} := {#2}}
\newcommand{\Sig}[3]{\definition{#1} \OFq {#2} {#3}}
\newcommand{\checkDefJ}[1]{{} \ENT {#1}}

\newcommand{\Case}[6]{\term{case}~ {#1} \OFq {#2} {#3} \mathrel{\term{to}} {#4} \mathrel{\term{via}} {#5} \mathrel{\term{of}} \left\{\overline{#6}\right\}}

\newcommand{\Clause}[2]{{#1} \shortrightarrow {#2}}

\newcommand{\mult}{\mathbin{\textcolor{type}{\times}}}
\newcommand{\proj}[1]{\mathop{\textcolor{definition}{\pi_{#1}}}}
\newcommand{\cons}[2]{\textcolor{term}{[}#1\textcolor{term}{,}\, #2\textcolor{term}{]}}
\newcommand{\nil}{\textcolor{term}{[]}}

\newcommand{\SigmaT}[3]{\textcolor{type}{(}\name #1 \OF #2 \textcolor{type}{)} \mult #3}
\newcommand{\PiT}[4]{\textcolor{type}{(}\name #1 \OF^{#2} #3 \textcolor{type}{)} \To #4}

% \newcommand{\PiT}[4]{\type{\Pi}\textcolor{type}{(}\name #1 \OF^{#2} #3 \textcolor{type}{)}. #4}
\newcommand{\Fun}{\type{\Pi}}
\newcommand{\PiTs}[5]{\underset{#1}{\Fun}\textcolor{type}{(}\name #2 \OF^{#3} #4 \textcolor{type}{)}. #5}

\newcommand{\PiTele}[4]{\overline{\textcolor{type}{(}\name #1 \OF^{#2} #3 \textcolor{type}{)}} \To #4}

\newcommand{\plus}{\mathbin{\textcolor{type}{+}}}
\newcommand{\inj}[1]{\mathop{\textcolor{term}{\iota_{#1}}}}
\newcommand{\match}[2]{\textcolor{definition}{\langle}#1\textcolor{definition}{,}\, #2\textcolor{definition}{\rangle}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \newcommand{\cOne}{\con \App \cons \dOne \nil}                                   %
% \newcommand{\cSigma}[2]{\con \App \cons \dSigma {\cons {#1}  {\cons {#2} \nil}}} %
% \newcommand{\cInd}[1]{\con \App \cons \dInd {\cons #1 \nil}}                     %
% \newcommand{\cHind}[2]{\con \App \cons \dHind {\cons #1  {\cons #2 \nil}}}       %
%                                                                                  %
% \newcommand{\uOne}{\underline{\dOne}}                                            %
% \newcommand{\uSigma}[2]{\underline{\dSigma} \App #1 \App #2}                     %
% \newcommand{\uInd}[1]{\underline{\dInd} \App #1}                                 %
% \newcommand{\uHind}[2]{\underline{\dHind} \App #1 \App #2}                       %
%                                                                                  %
% \newcommand{\con}{\term{con}}                                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{biblatex}
\bibliography{references.bib}

\begin{document}

\maketitle

We extract a set of typing rules for the hole-free fragment of Idris' new core, Yaffle\footnote{See \href{https://github.com/edwinb/Yaffle/blob/main/src/Core/Check/Typecheck.idr}{{\texttt{Core.Check.Typecheck}}} and \href{https://github.com/edwinb/Yaffle/blob/main/src/Core/Check/Linear.idr}{\texttt{Core.Check.Linear}} in repository \url{https://github.com/edwinb/Yaffle}.}

Idris splits the world into expressions that are present at runtime and those that may be erased after type-checking. This is enforced via quantity annotations on variables in context
\begin{itemize}
\item quantities $p, q \mathrel{\text{::=}} \zero, \one, \any$ with $\zero < \one < \any$
\item contexts $\Gamma \mathrel{\text{::=}} \EMPTY \mid \Gamma, (\name x \OFq q T)$
\end{itemize}
Informally, runtime-present expressions can only depend on variables at quantity $\one$ or $\any$, where $\one$-annotated variables must be used exactly once and $\any$-annotated variables can be used arbitrarily. In contrast, erased expressions have unrestricted access to all variables, including $\zero$-annotated variables.

The context records the number of copies available of each variable; it does not account for exact variable usage inside the term to be checked\footnote{This is departure from Atkey's presentation of QTT\cite{Atkey2018}.}. Type checking only enforces that variable usage adheres to this budget locally but, in particular, does not enforce that linear variables are used precisely once. This is left to the \hyperref[sec:linearity_checking]{linearity checker}, which runs after type checking.

We will frequently need to multiply quantities, turning the set of  quantities into a monoid
\begin{mathpar}
\begin{array}{l}
\multQ \one y = y\\
\multQ x \one = x\\\\
\multQ \zero y = \zero\\
\multQ x \zero = \zero\\\\
\multQ \any \any = \any
\end{array}
\end{mathpar}

When manipulating the context, we will also need a restriction operation $\restrictQ p q$, which makes $p$-annotated variables that do not support at least $q$ copies unavailable at runtime
\begin{mathpar}
\restrictQ p q =
  \left\{
    \begin{array}{ll}
      p & \text{if $p \leq q$} \\
      \zero & \text{otherwise}
    \end{array}
  \right.
\end{mathpar}
Concretely,
\begin{mathpar}
\begin{array}{l}
\restrictQ p \zero = p\\
\restrictQ p \one = p\\
\restrictAny \zero = \zero\\
\restrictAny \one = \zero\\
\restrictAny \any = \any
\end{array}
\end{mathpar}
and lifted to contexts
\begin{mathpar}
\begin{array}{ll}
\restrictQ {\EMPTY} p = \EMPTY\\
\restrictQ {\Gamma, (x \OFq q T)} p = \restrictQ \Gamma p, (x \OFq {\restrictQ q p} T)
\end{array}
\end{mathpar}
Note that $\Gamma = \restrictQ \Gamma \zero = \restrictQ \Gamma \one$.

\section{Quantity-annotated judgements}

The type-checker follows a bidirectional discipline, elaborating a domain-free\footnote{Meaning binders are not type-annotated, c.f.~\cite{Barthe2000}} bidirectional language\footnote{Checkable terms \texttt{RawC} and inferrable terms \texttt{RawI} are defined in \href{https://github.com/edwinb/Yaffle/blob/main/src/Core/Syntax/Raw.idr}{Core.Syntax.Raw}.} to a conventional domain-full language\footnote{Defined as \texttt{Term} in \href{https://github.com/edwinb/Yaffle/blob/main/src/Core/TT/TT.idr}{Core.TT.TT}.}. We give a type system for the latter.

Judgement $\checkJ \Sigma \Gamma t p A$ amounts to checking that term $t$ has type $A$ in context $\Gamma$ at {\em ambient} quantity $p$ with definitions $\Sigma$. The ambient quantity has dual purpose. Much like QTT's erased/present flag~\cite{Atkey2018}, it controls whether the expression to be checked is considered to be erased ($\zero$) or present ($\one$ or $\any$). It also acts as cost multiplier for variable accesses: suppose we want to infer the type of an application $\App \any f t$ at ambient quantity $\one$ and already know that $\checkJ \Sigma \Gamma f \one {\PiT x \any A B}$. We now not only need to check that argument $t$ has type $A$ but also that we are allowed to make $\any$ copies of $t$. One way to achieve this would be to restrict the context to those variables that support $\any$ copies, i.e. $\checkJ \Sigma {\restrictAny \Gamma} t {\one} A$. Idris, however, uses a variable rule that requires any accessed variable to have quantity larger or equal to the ambient quantity
\begin{mathpar}
\inferrule*[Right=Var]{
  (\name x \OFq q A) \in \Gamma\\
  p \leq q
} {
  \checkJ \Sigma \Gamma {\name x} p A
}
\end{mathpar}
allowing us to use $\checkJ \Sigma \Gamma t \any A$ instead. In fact, we should always have $$\checkJ \Sigma \Gamma t {p} A \iff \checkJ \Sigma {\restrictQ \Gamma p} t {\presence p} A$$ where $\presence p$ squashes quantity $p$ down to just its presence
\begin{mathpar}
\begin{array}{l}
\presence \zero = \zero\\
\presence \one = \one\\
\presence \any = \one
\end{array}
\end{mathpar}

\section{Syntax}

$$
\begin{array}{lrll}
  \text{expressions } {t, s, e, f, A, B} &\mathrel{\text{::=}} &\name x & \text{variables ${\name x} \in \mathbb V$}\\
  &\mid &\definition f & \text{defined functions}\\
  &\mid &\TyCon {\definition tc} & \text{type constructors}\\
  &\mid &\DataCon {\definition dc} & \text{data constructors}\\
  &\mid &\lam x q A t\\
  &\mid &\Let x q A t s\\
  &\mid &\PiT x q A B & \text{function types}\\
  &\mid &\App q f t & \text{function application}\\
  &\mid &c\\
  &\mid &\Type\\
  \\
  \text{constants } {c} &\mathrel{\text{::=}} &n & \text{$n \in \mathbb N$}\\
  &\mid &\ldots\\
  &\mid &\type{Int}\\
  &\mid &\ldots\\
  \\
  \text{declarations } {d} &\mathrel{\text{::=}} &\definition f \OFq q A & \text{function signature}\\
      &\mid &\definition f = t & \text{function definition}

\end{array}
$$

\section{Type checking}

\subsection{Type conversion}
\begin{mathpar}
\inferrule*[Right=Conv]{
  \checkJ \Sigma \Gamma e p B\\
  \convJ \Gamma A B \zero \Type
} {
  \checkJ \Sigma \Gamma e p A
}
\end{mathpar}

\subsection{Variables}

\begin{mathpar}
\inferrule*[Right=Var]{
  (\name x \OFq q A) \in \Gamma\\
  p \leq q
} {
  \checkJ \Sigma \Gamma {\name x} p A
}
\end{mathpar}

\subsection{Function type}

\begin{mathpar}
\inferrule*[Right=Pi]{
  \checkJ \Sigma \Gamma A \zero \Type \\
  \checkJ \Sigma {\Gamma, (\name x \OFq q {A})} B \zero \Type
} {
  \checkJ \Sigma \Gamma {\PiT x q A B} p \Type
}
\end{mathpar}

\subsection{Function abstraction}

\begin{mathpar}
\inferrule*[Right=Lam]{
  \checkJ \Sigma {\restrictQ \Gamma p, (\name x \OFq q A)} t {\presence p} B
} {
  \checkJ \Sigma \Gamma {\lam x q A t} p {\PiT x q A B}
}
\end{mathpar}

\subsection{Function application}
\begin{mathpar}
\inferrule*[Right=App] {
  \checkJ \Sigma \Gamma f p {\PiT x q A B} \\
  \checkJ \Sigma \Gamma t {pq} A
} {
  \checkJ \Sigma \Gamma {\App q f t} p {\Sub B t x}
}
\end{mathpar}
Note: Idris only restricts the context when introducing a linear variable at ambient quantity $\any$. We do not replicate this optimisation in the rules.

\subsection{Let binding}
\begin{mathpar}
\inferrule*[Right=Let]{
  \checkJ \Sigma \Gamma A \zero \Type\\
  \checkJ \Sigma \Gamma t {p q} A\\
  \checkJ {\restrictQ \Gamma p, (\name x \OFq q A)} s {\presence p} B
} {
  \checkJ \Sigma \Gamma {\Let x q A t s} p B
}
\end{mathpar}

\subsection{Case}

\begin{mathpar}
\inferrule*[Right=Case]{
  \checkJ \Sigma \Gamma e {p q} {\AppTele {\TyCon {tc}} {q_i} {t_i}} \\
  \checkJ \Sigma \Gamma \delta p \Delta \\
  \checkJ \Sigma {\Delta, (\name x \OFq q {\AppTele {\TyCon {tc}} {q_i} {{\name y}_i}})} A \zero \Type \\\\
  \definition{dc}_i \OF {\Delta_i \to {\App {} {\TyCon {tc}} {\delta_i}}} \in \Sigma\\
  \Gamma \ENTq {\presence p q} {\definition {dc}}_i\, t_{1} \ldots t_{n_i} \OF \Delta \\
  \Gamma \mathrel{\textbackslash} p, \name x_i \OFq {q s_i} {A_i} \ENTq {\presence p} e_i \\\\
  \presence p = \one \land q = \zero \implies i \leq 1
} {
  \checkJ \Sigma \Gamma
    {\Case e
      q
      {\AppTele {\TyCon {tc}} {q_i} {t_i}}
      {\name x. A}
      {\delta \OF \Gamma \to \Delta}
      {\Clause {{\definition {dc}}_i\, x_{1} \ldots x_{n_i}} {e_i}}
    }
    q
    {\Sub A e x}
}
\end{mathpar}

\subsection{Constants}
\begin{mathpar}
\inferrule*[Right=Int]{ } {
  \checkJ \Sigma \Gamma {\type{Int}} p \Type
}
\end{mathpar}

\begin{mathpar}
\inferrule*[Right=Int-Const]{
  (n \in \mathbb N)
} {
  \checkJ \Sigma \Gamma {n} p {\type{Int}}
}
\end{mathpar}

\subsection{Universe}
\begin{mathpar}
\inferrule*[Right=Type]{ } {
  \checkJ \Sigma \Gamma \Type p \Type
}
\end{mathpar}
Note: Yaffle currently has type-in-type but cumulative universes are on the roadmap.

\subsection{Defined functions}
\begin{mathpar}
\inferrule*[Right=ref] {
  \left( \Sig f q A \right) \in \Sigma\\
  {\presence p} \leq q
} {
  \checkJ \Sigma \Gamma {\definition f} p A
}
\end{mathpar}


% \subsection{Meta-variables}
% \begin{mathpar}
% \inferrule*[Right=MetaApp-def] {
%   (X = d) \in \Sigma \\
%   \Gamma \ENTq {pq_i} t_i \leadsto {t'_i} \USES u_i
% } {
%   \Gamma \ENTq p {\MetaApp X {q_i} {t_i}} \leadsto \MetaApp X {q_i} {\deleteQ {t'_i} {q_i}} \USES \bigcup u_i
% }

% \inferrule*[Right=MetaApp-undef] {
%   X \in \Sigma
% } {
%   \Gamma \ENTq p {\MetaApp X {q_i} {t_i}} \leadsto \MetaApp X {q_i} {\deleteQ {t_i} {q_i}} \USES \emptyset
% }
% \end{mathpar}

\section{Definitions}

A Yaffle file consists of a sequence of declarations
$$\Sigma \mathrel{\text{::=}} \EMPTY \mid {\Sigma, d}$$
which we call well-typed if judgment $\checkDefJ \Sigma$ holds.

\subsection{Data types}

\begin{mathpar}
\inferrule*[Right=Empty] { } {
  \checkDefJ \EMPTY
}
\end{mathpar}


\begin{mathpar}
\inferrule*[Right=Def-TyCon] {
  \checkJ \Sigma \EMPTY {\PiTele {x_i} {q_i} {T_i} \Type} \zero \Type
} {
  \checkDefJ
  {\Sigma,
    {\definition{tc} \OF {\PiTele {x_i} {q_i} {T_i} \Type}}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule*[Right=Def-DataCon] {
  \left( \definition{tc} \OF {\PiTele {x_i} {q_i} {T_i} \Type} \right) \in \Sigma\\\\
  \checkJ \EMPTY {\PiTele {y_j} {r_j} {A_j} {\AppTele {\TyCon {tc}} {q_i} {t_i}}} \zero \Type
} {
  \checkDefJ {\Sigma, {\definition{dc} \OF {\PiTele {y_j} {r_j} {A_j} {\AppTele {\TyCon {tc}} {q_i} {t_i}}}}}
}
\end{mathpar}
Note: to keep the presentation simple, we leave data types open to extension. Strict-positivity check has not been implemented yet.

\begin{mathpar}
\inferrule*[Right=TyCon] {
  \left( \definition{tc} \OF {\PiTele {x_i} {q_i} {T_i} \Type} \right) \in \Sigma
} {
  \checkJ \Sigma \Gamma {\TyCon {tc}} p {\PiTele {x_i} {q_i} {T_i} \Type}
}
\end{mathpar}

\begin{mathpar}
\inferrule*[Right=DataCon] {
  \left( \definition{dc} \OF {\PiTele {y_j} {r_j} {A_j} {\AppTele {\TyCon {tc}} {q_i} {t_i}}} \right) \in \Sigma
} {
  \checkJ \Sigma \Gamma {\DataCon {dc}} p {\PiTele {y_j} {r_j} {A_j} {\AppTele {\TyCon {tc}} {q_i} {t_i}}}
}
\end{mathpar}

\subsection{Functions}

Functions signature and definitions are defined separately to allow mutually recursive definitions. We do not check termination and also do not prevent re-definition.
\begin{mathpar}
\inferrule*[Right=Sig] {
  \checkDefJ \Sigma\\
  \checkJ \Sigma \EMPTY A \zero \Type\\
  (q \in \{\zero, \one\})
} {
  \checkDefJ {\Sigma, \Sig f q A}
}
\end{mathpar}

\begin{mathpar}
\inferrule*[Right=Def] {
  \checkDefJ \Sigma\\
  \left( \Sig f q A \right) \in \Sigma\\
  \checkJ \Sigma \EMPTY t q A\\
  \linCheckJ \EMPTY t q \emptyset\\
} {
  \checkDefJ {\Sigma, \Def f t}
}
\end{mathpar}
The last premise, $\linCheckJ \EMPTY t q \emptyset$, invokes the linearity checker.

\section{Conversion}

Idris combines CBV-evaluation with an untyped eta-conversion check\footnote{See \href{https://github.com/edwinb/Yaffle/blob/main/src/Core/Evaluate/Normalise.idr}{\texttt{Core.Evaluate.Normalise.evaluate}} and \href{https://github.com/edwinb/Yaffle/blob/main/src/Core/Evaluate/Convert.idr}{\texttt{Core.Evaluate.Convert.convGen}}.}. The plan to make conversion checking typed.

We present the intended equational theory

\begin{mathpar}
\inferrule*[Right=$\beta$] {
  \checkJ \Sigma {\restrictQ \Gamma p, (\name x \OFq q A)} e {\presence p} B\\
  \checkJ \Sigma \Gamma t {pq} A\\
} {
  \checkEqJ \Sigma \Gamma {\App q {\lam x q A e} t} {\Sub e t x} p {\Sub B t x}
}
\end{mathpar}

\begin{mathpar}
\inferrule*[Right=$\eta$] {
  \checkJ \Sigma \Gamma f p {\PiT x q A B}\\
  \name x \not\in {\fv f}
} {
  \checkEqJ \Sigma \Gamma f {\lam x q A {\App q f {\name x}}} p {\PiT x q A B}
}
\end{mathpar}

\begin{mathpar}
\inferrule*[Right=Let-$\delta$] {
  \checkJ \Sigma \Gamma A \zero \Type\\
  \checkJ \Sigma \Gamma t {pq} A\\
  \checkJ \Sigma {\restrictQ \Gamma p, (\name x \OFq q A)} s {\presence p} B
} {
  \checkEqJ \Sigma \Gamma {\Let x q A t s} {\Sub s t x} p B
}
\end{mathpar}

\begin{mathpar}
\inferrule*[Right=Def-$\delta$] {
  \left( \Def f q A t \right) \in \Sigma\\
  \presence p \leq q
} {
  \checkEqJ \Sigma \Gamma {\definition f} t p A
}
\end{mathpar}

\section{Linearity checking}\label{sec:linearity_checking}

We record usage of linear variables as a multiset $u \in \mathbb V \to \mathbb N$ with the following operations:

\begin{itemize}
\item empty usage
  $$
  \emptyset = \name y \mapsto 0
  $$
\item singleton usage
  $$
  \{ \name x \} = \name y \mapsto {\begin{cases}1 & \text{if $\name y = \name x$}\\ 0 & \text{otherwise} \end{cases}}
  $$
\item linear variable usage
  $$
  \used p {\name x} = {\begin{cases}\{\name x\} & \text{if $p = \one$}\\ \emptyset  & \text{otherwise} \end{cases}}
  $$
\item variable deletion
  $$
  u \setminus {\name x} = \name y \mapsto {\begin{cases}0 & \text{if $\name y = \name x$}\\ u(\name y) & \text{otherwise} \end{cases}}
  $$
\end{itemize}

\begin{mathpar}
\inferrule*[Right=Var]{
  (\name x \OFq q A) \in \Gamma\\
  p \leq q
} {
  \linCheckJ \Gamma {\name x} p {\used p x}
}
\end{mathpar}

\begin{mathpar}
\inferrule*[Right=Lam]{
  \linCheckJ {\restrictQ \Gamma p, (\name x \OFq q A)} t {\presence p} u \\
  pq = \one \implies u(\name x) = 1
} {
  \linCheckJ \Gamma {\lam x q A t} p {u \smallsetminus \name x}
}
\end{mathpar}

\printbibliography

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
